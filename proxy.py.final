import requests
import json
import subprocess
import time
import os
from fastapi import FastAPI

app = FastAPI()

ELECTRS_URL = "http://127.0.0.1:3002"
RPC_CMD = ["/root/Bitever/src/bitcoin-cli", "-datadir=/root/myfork", "-rpcuser=user", "-rpcpassword=pass", "-rpcport=8334"]

# 파일 기반 영구 캐시 설정
CACHE_FILE = "p2pk_scan_results.json"

# 1. 기존 매핑 데이터 로드 (주소: RawScript)
try:
    with open("p2pk_map.json", "r") as f:
        P2PK_DB = json.load(f)
except FileNotFoundError:
    P2PK_DB = {}

# 2. 영구 스캔 캐시 로드 (주소: ScanResult)
if os.path.exists(CACHE_FILE):
    with open(CACHE_FILE, "r") as f:
        SCAN_CACHE = json.load(f)
else:
    SCAN_CACHE = {}

def save_cache():
    """스캔 결과를 파일에 영구 저장"""
    with open(CACHE_FILE, "w") as f:
        json.dump(SCAN_CACHE, f, indent=4)

def get_rpc_data_with_persistence(address):
    """영구 캐시 확인 후 없으면 스캔 실행"""
    if address in SCAN_CACHE:
        return SCAN_CACHE[address]

    raw_script = P2PK_DB.get(address)
    if not raw_script:
        return None

    try:
        # 기존 스캔 중단
        subprocess.run(RPC_CMD + ["scantxoutset", "abort"], capture_output=True)
        time.sleep(0.5)
        
        print(f"[{address}] 신규 스캔 시작 (영구 저장 예정)...")
        rpc_res = subprocess.check_output(RPC_CMD + ["scantxoutset", "start", f'["raw({raw_script})"]'])
        result = json.loads(rpc_res)
        
        if result.get("success"):
            # 메모리에 저장 후 파일로 쓰기
            SCAN_CACHE[address] = result
            save_cache()
            return result
    except Exception as e:
        print(f"RPC 오류: {e}")
    return None

@app.get("/api/address/{address}")
async def get_address(address: str):
    resp = requests.get(f"{ELECTRS_URL}/address/{address}")
    data = resp.json()

    if address in P2PK_DB:
        utxo_info = get_rpc_data_with_persistence(address)
        if utxo_info:
            total_satoshis = int(utxo_info.get("total_amount", 0) * 100000000)
            if "chain_stats" not in data: data["chain_stats"] = {}
            data["chain_stats"]["funded_txo_sum"] = total_satoshis
            data["chain_stats"]["tx_count"] = len(utxo_info.get("unspents", []))
        data["address"] = address
    return data

@app.get("/api/address/{address}/{sub_path:path}")
async def proxy_address_subpath(address: str, sub_path: str):
    if address in P2PK_DB:
        utxo_info = get_rpc_data_with_persistence(address)
        
        if sub_path == "utxo":
            if utxo_info:
                return [{
                    "txid": item["txid"], "vout": item["vout"], "value": int(item["amount"] * 100000000),
                    "status": {"confirmed": True, "block_height": item["height"]}
                } for item in utxo_info.get("unspents", [])]
            return []
        
        if sub_path == "txs":
            if not utxo_info or not utxo_info.get("unspents"):
                return []
            
            tx_list = []
            for item in utxo_info["unspents"]:
                try:
                    raw_tx = subprocess.check_output(RPC_CMD + ["getrawtransaction", item["txid"], "1"])
                    tx_data = json.loads(raw_tx)
                    for vout in tx_data.get("vout", []):
                        if "value" in vout:
                            vout["value"] = int(vout["value"] * 100000000)
                    
                    tx_list.append({
                        "txid": tx_data["txid"], "version": tx_data["version"], "locktime": tx_data["locktime"],
                        "vin": tx_data["vin"], "vout": tx_data["vout"],
                        "status": {"confirmed": True, "block_height": item["height"], "block_hash": tx_data.get("blockhash")},
                        "fee": 0, "sigops": 1
                    })
                except: continue
            return tx_list

    resp = requests.get(f"{ELECTRS_URL}/address/{address}/{sub_path}")
    try: return resp.json()
    except: return []

